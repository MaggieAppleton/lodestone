import { db, DynamicQuestion } from "../db";
import { OpenAIService } from "./models/openai";

// Default questions to show when user starts typing
const DEFAULT_QUESTIONS = [
	"What do you currently believe about this?",
	"What do you want to say about it?",
	"Why is this an interesting problem?",
];

// Configuration for question generation
const QUESTION_CONFIG = {
	minCharsBeforeGeneration: 100, // Minimum characters before generating questions
	minTimeBetweenCalls: 6000, // Minimum time between API calls (6 seconds)
	maxQuestionsVisible: 3, // Maximum questions visible at once
	debounceTime: 500, // Debounce time for typing (ms)
};

interface GenerateQuestionsOptions {
	text: string;
	sessionId: number;
	topic: string;
	apiKey: string;
	previousQuestions?: string[]; // Previously shown questions to avoid repeating
}

export class DynamicQuestionsService {
	private static lastApiCallTime: number = 0;
	private static openaiService = new OpenAIService("gpt4o-mini");

	/**
	 * Add default questions for a session
	 */
	static async addDefaultQuestions(
		sessionId: number
	): Promise<DynamicQuestion[]> {
		// First check if default questions already exist to prevent duplication
		try {
			console.log(
				"Checking for existing default questions for session",
				sessionId
			);
			const existingDefaultQuestions = await db.dynamicQuestions
				.where("sessionId")
				.equals(sessionId)
				.and((q) => q.isInitialQuestion === true)
				.toArray();

			if (existingDefaultQuestions.length > 0) {
				console.log(
					"Found existing default questions:",
					existingDefaultQuestions.length
				);
				return existingDefaultQuestions;
			}
		} catch (error) {
			console.error("Error checking for existing default questions:", error);
			// Continue anyway to attempt creating new questions
		}

		// Create default question objects
		const questions: DynamicQuestion[] = DEFAULT_QUESTIONS.map((question) => ({
			sessionId,
			question,
			generatedAt: new Date(),
			triggeringText: "",
			isInitialQuestion: true,
			wasShown: true,
			shownAt: new Date(),
		}));

		// Add questions to the database
		try {
			console.log(
				"Adding default questions to database for session",
				sessionId
			);

			// Add each question individually with explicit error handling
			const ids: number[] = [];
			for (const question of questions) {
				try {
					const id = await db.dynamicQuestions.add(question);
					ids.push(id);
				} catch (innerError) {
					console.error(
						"Error adding individual default question:",
						innerError,
						question
					);
				}
			}

			console.log("Successfully added default questions, count:", ids.length);

			// Return the questions with their ids
			return questions.map((q, i) => ({ ...q, id: ids[i] }));
		} catch (error) {
			console.error("Error adding default questions to database:", error);
			// Return empty array instead of throwing to prevent breaking the application flow
			return [];
		}
	}

	/**
	 * Generate new questions based on the current text
	 */
	static async generateQuestions(
		options: GenerateQuestionsOptions
	): Promise<DynamicQuestion[]> {
		const now = Date.now();
		const timeSinceLastCall = now - this.lastApiCallTime;

		// Check rate limiting
		if (timeSinceLastCall < QUESTION_CONFIG.minTimeBetweenCalls) {
			return [];
		}

		this.lastApiCallTime = now;

		try {
			// Construct a prompt for the OpenAI API
			const prompt = this.constructQuestionPrompt(options);
			console.log("Sending request to OpenAI for question generation");

			// Call the generateQuestions method from OpenAI service
			const questionsText = await this.openaiService.generateQuestions(
				options.text,
				prompt,
				{
					apiKey: options.apiKey,
					model: "gpt-4o-mini",
				}
			);
			console.log("Received questions from OpenAI:", questionsText);

			if (!questionsText.length) {
				console.warn("No questions were generated by the model");
				return [];
			}

			// Create DynamicQuestion objects
			const questions: DynamicQuestion[] = questionsText.map((question) => ({
				sessionId: options.sessionId,
				question,
				generatedAt: new Date(),
				triggeringText: options.text.slice(-200), // Store the last 200 chars as triggering text
				isInitialQuestion: false,
				wasShown: false,
			}));

			// Add to database
			const ids = await db.transaction("rw", db.dynamicQuestions, async () => {
				return await Promise.all(
					questions.map((q) => db.dynamicQuestions.add(q))
				);
			});
			console.log(
				"Added new dynamic questions to database, count:",
				ids.length
			);

			// Return with ids
			return questions.map((q, i) => ({ ...q, id: ids[i] }));
		} catch (error) {
			console.error("Error generating questions:", error);
			return [];
		}
	}

	/**
	 * Get questions for display, prioritizing ones that haven't been shown
	 */
	static async getQuestionsForDisplay(
		sessionId: number,
		limit: number = QUESTION_CONFIG.maxQuestionsVisible
	): Promise<DynamicQuestion[]> {
		console.log(
			`Getting questions for display for session ${sessionId}, limit: ${limit}`
		);

		let dynamicQuestions: DynamicQuestion[] = [];
		let defaultQuestions: DynamicQuestion[] = [];

		try {
			// Find all dynamic (non-default) questions
			dynamicQuestions = await db.dynamicQuestions
				.where("sessionId")
				.equals(sessionId)
				.and((q) => q.isInitialQuestion === false && !q.removedAt)
				.sortBy("generatedAt");

			console.log(`Found ${dynamicQuestions.length} dynamic questions`);
		} catch (error) {
			console.error("Error fetching dynamic questions:", error);
		}

		try {
			// Find all default questions
			defaultQuestions = await db.dynamicQuestions
				.where("sessionId")
				.equals(sessionId)
				.and((q) => q.isInitialQuestion === true && !q.removedAt)
				.sortBy("generatedAt");

			console.log(`Found ${defaultQuestions.length} default questions`);
		} catch (error) {
			console.error("Error fetching default questions:", error);
		}

		// Prepare the final list of questions to display
		let questionsToDisplay: DynamicQuestion[] = [];

		// First add dynamic questions (unshown first, then shown)
		const unshownDynamic = dynamicQuestions.filter((q) => !q.wasShown);
		const shownDynamic = dynamicQuestions.filter((q) => q.wasShown);

		// Add unshown dynamic questions first
		questionsToDisplay = questionsToDisplay.concat(unshownDynamic);

		// If we still have space, add shown dynamic questions
		if (questionsToDisplay.length < limit) {
			// Sort shown by most recently shown
			const recentShown = [...shownDynamic].sort((a, b) => {
				if (!a.shownAt || !b.shownAt) return 0;
				return b.shownAt.getTime() - a.shownAt.getTime();
			});
			questionsToDisplay = questionsToDisplay.concat(
				recentShown.slice(0, limit - questionsToDisplay.length)
			);
		}

		// If we still need more questions to reach the limit, add default questions
		if (questionsToDisplay.length < limit && defaultQuestions.length > 0) {
			// Calculate how many default questions we need
			const defaultsNeeded = limit - questionsToDisplay.length;

			// Only add as many default questions as needed to reach the limit
			questionsToDisplay = questionsToDisplay.concat(
				defaultQuestions.slice(0, defaultsNeeded)
			);
		}

		// Make sure we don't exceed the limit
		questionsToDisplay = questionsToDisplay.slice(0, limit);

		console.log(`Returning ${questionsToDisplay.length} questions for display`);

		// If we have questions to display, mark unshown ones as shown
		if (questionsToDisplay.length > 0) {
			const now = new Date();
			try {
				// Only mark questions that haven't been shown yet
				const unshownQuestions = questionsToDisplay.filter((q) => !q.wasShown);

				if (unshownQuestions.length > 0) {
					console.log(`Marking ${unshownQuestions.length} questions as shown`);

					for (const q of unshownQuestions) {
						if (q.id) {
							try {
								await db.dynamicQuestions.update(q.id, {
									wasShown: true,
									shownAt: now,
								});
								// Also update the local object so our return value is accurate
								q.wasShown = true;
								q.shownAt = now;
							} catch (updateError) {
								console.error(`Error updating question ${q.id}:`, updateError);
							}
						}
					}
				}
			} catch (error) {
				console.error("[DQS] Error marking questions as shown:", error);
			}
		}

		return questionsToDisplay;
	}

	/**
	 * Get all questions for a session
	 */
	static async getAllQuestions(sessionId: number): Promise<DynamicQuestion[]> {
		const questions = await db.dynamicQuestions
			.where({ sessionId })
			.filter((q) => !q.removedAt)
			.sortBy("generatedAt");
		return questions;
	}

	/**
	 * Mark questions as removed (for cycling out)
	 */
	static async markQuestionsAsRemoved(questionIds: number[]): Promise<void> {
		const now = new Date();
		await db.transaction("rw", db.dynamicQuestions, async () => {
			for (const id of questionIds) {
				await db.dynamicQuestions.update(id, { removedAt: now });
			}
		});
	}

	// Helper method to construct the question generation prompt
	private static constructQuestionPrompt(
		options: GenerateQuestionsOptions
	): string {
		const previousQuestionsText = options.previousQuestions?.length
			? `Previously asked questions (don't repeat these):\n${options.previousQuestions.join(
					"\n"
			  )}`
			: "";

		return `
You are a critical thinking assistant helping a writer develop their ideas on the topic: "${
			options.topic
		}".

Based on what they've written so far, generate 3-4 thought-provoking questions that will help them explore their ideas more deeply.

Good questions should:
- Be specific to the content they've written
- Push them to consider different perspectives
- Help them elaborate on their reasoning
- Be concise (no more than 20 words each)
- Focus on critical thinking

Their current text:
${options.text.slice(-1000)} [...]

${previousQuestionsText}

Return only the questions as a valid JSON array of strings. For example:
["Question 1?", "Question 2?", "Question 3?"]
`;
	}

	/**
	 * Clean up duplicate default questions for a session
	 * This is a utility method to fix the database if there are duplicate default questions
	 */
	static async cleanupDuplicateDefaultQuestions(
		sessionId: number
	): Promise<void> {
		// Find all default questions for this session
		const defaultQuestions = await db.dynamicQuestions
			.where({ sessionId, isInitialQuestion: true })
			.toArray();

		// If we have more than the expected number of default questions, we have duplicates
		if (defaultQuestions.length > DEFAULT_QUESTIONS.length) {
			// Group questions by their text
			const questionGroups = new Map<string, DynamicQuestion[]>();
			defaultQuestions.forEach((q) => {
				const existing = questionGroups.get(q.question) || [];
				existing.push(q);
				questionGroups.set(q.question, existing);
			});

			// For each group, keep the oldest one and mark the rest as removed
			const toRemove: number[] = [];

			questionGroups.forEach((questions) => {
				// Sort by ID (older questions have lower IDs)
				questions.sort((a, b) => (a.id || 0) - (b.id || 0));

				// Keep the first one, mark the rest for removal
				const duplicates = questions.slice(1);

				duplicates.forEach((q) => {
					if (q.id) toRemove.push(q.id);
				});
			});

			// Mark the duplicates as removed
			if (toRemove.length > 0) {
				console.log(`Removing ${toRemove.length} duplicate default questions`);
				await this.markQuestionsAsRemoved(toRemove);
			}
		}
	}
}
